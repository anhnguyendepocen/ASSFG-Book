# Standardized Incidence Ratios

This material is taken from Chapter 5 of @Moraga2020. https://www.paulamoraga.com/book-geospatial/sec-geostatisticaldataexamplespatial.html

The standardized incidence ratio (SIR) is defined as the ratio of the observed to the expected number of disease cases. But, small areas may present extreme SIRs due to low population sizes or small samples. In these situations, SIRs may be misleading and unreliable for reporting. In these cases it is better to estimate disease risk using a spatial statistical model. Models can incorporate information from neighboring areas and covariate information resulting in smoothing (shrinking) of extreme values.

The Besag-York-Mollié (BYM) model [@BesagEtAl1991] is a popular way to account for spatial autocorrelation. The model smooths the data according to a neighborhood structure. In spatio-temporal settings where disease counts are observed over time, spatio-temporal models that account for spatial structure and temporal correlations and their interactions are used.

## Defining neighbors

The example here is based on data of lung cancer in Pennsylvania counties, US, obtained from the {SpatialEpi} package [@KimWakefield2018], and show results with maps created with the {ggplot2} package [@Wickham2016].

The county bounderies for the state are in the list object `pennLC` with element name `spatial.polygon`. We change the native spatial polygons S4 object to an S3 simple feature data frame using the `st_as_sf()` function from the {sf} package [@Pebesma2018]. We use the `plot()` method on the `geometry` column to make a simple map.
```{r}
library(SpatialEpi)
library(sf)

spdf <- pennLC$spatial.polygon
sfdf <- st_as_sf(spdf)
plot(sfdf$geometry)
```

We obtain the neighbors of each county using the `poly2nb()` function from the {spdep} package [@BivandEtAl2008]. This function returns a neighbors list, here saved as `nb`, based on counties with contiguous boundaries. Each element of the list `nb` represents one county and contains the indices of its neighbors. For example, `nb[[2]]` contains the neighbors of county 2.
```{r}
library(spdep)

nb <- poly2nb(sfdf)
head(nb)
```

We show the neighbors of each county on a map highlighting neighbors of counties 2, 44 and 58. First, we create a `SpatialPolygonsDataFrame` object with the map of Pennsylvania, and data that contains a variable called county with the county names, and a dummy variable called `neigh` that indicates the neighbors of counties 2, 44 and 58. neigh is equal to 1 for counties that are neighbors of counties 2, 44 and 58, and 0 otherwise.
```{r}
df <- data.frame(county = names(spdf), 
                 neigh = rep(0, length(spdf)))
rownames(df) <- names(spdf)

spdf <- SpatialPolygonsDataFrame(spdf, df, match.ID = TRUE)

# to highlight neighbors of counties 2, 44, and 58
spdf$neigh[nb[[2]]] <- 1
spdf$neigh[nb[[44]]] <- 1
spdf$neigh[nb[[58]]] <- 1
```

Then, we add variables called `long` and `lat` with the centroid coordinates for each county, and a variable `ID` identifying each county.
```{r}
coord <- st_coordinates(st_centroid(sfdf))

sfdf$neigh <- spdf$neigh
sfdf$long <- coord[, 1]
sfdf$lat <- coord[, 2]
sfdf$ID <- 1:nrow(coord)
```

We create the map with the `ggplot()` function from {ggplot2}.
```{r}
library(ggplot2)

ggplot(sfdf) + 
  geom_sf(aes(fill = as.factor(neigh))) +
  geom_text(aes(long, lat, label = ID), color = "white") +
  theme_minimal() + 
  guides(fill = FALSE)
```

We see that county number 2 has counties 3, 4, 10, 63, and 62 as neighbors. County 44 has counties 14, 31, 34, 55, and 60 as neighbors. 

Other neighborhood definitions can be considered (see Chapter 3).

## Standardized incidence ratio

A simple measure of disease risk is the standardized incidence ratio (SIR). For each region $i$, $i = 1, \ldots, n$ the SIR is defined as the ratio of observed counts to the expected counts
$$
\hbox{SIR}_i = Y_i/E_i.
$$

The expected count $E_i$ is the total number of cases that one would expect if the population of area $i$ behaves the way the standard population behaves. If we ignore differences in rates for different stratum (e.g., age groups) then we compute the expected counts as
$$
E_i = r^{(s)} n^{(i)},
$$
where $r^{(s)}$ is the rate in the standard population (total number of cases divided by the total population across all regions), amd $n^{(i)}$ is the population of region $i$.

$\hbox{SIR}_i$ indicates whether region $i$ has higher ($\hbox{SIR}_i > 1$), equal ($\hbox{SIR}_i = 1$) or lower ($\hbox{SIR}_i < 1$) risk than expected relative to the standard population.

When applied to mortality data, the ratio is known as the standardized mortality ratio (SMR).

### Example: Lung cancer in Pennsylvania

The data frame `pennLC$data` from the {SpatialEpi} package contains the number of lung cancer cases and the population of Pennsylvania at county level, stratified on race (white and non-white), gender (female and male) and age (under 40, 40-59, 60-69 and 70+). 

We obtain the number of cases for all the strata together in each county, Y, by aggregating the rows of `pennLC$data` by county and adding up the number of cases.
```{r}
library(dplyr)

( County.df <- pennLC$data %>%
  group_by(county) %>%
  summarize(Y = sum(cases)) )
```

We calculate the expected number of cases in each county using indirect standardization. The expected counts in each county represent the total number of disease cases one would expect if the population in the county behaved the way the population of Pennsylvania behaves. We can do this by using the `expected()` function from the {SpatialEpi} package. This function has three arguments, namely,

* `population`: vector of population counts for each strata in each area,
* `cases`: vector with the number of cases for each strata in each area,
* `n.strata`: number of strata.

The vectors `population` and `cases` need to be sorted by area first and then, within each area, the counts for all strata need to be listed in the same order. All strata need to be included in the vectors, including strata with 0 cases. Here we use the `arrange()` function from the {dplyr} package.
```{r}
( Strata.df <- pennLC$data %>%
  arrange(county, race, gender, age) )
```

Then, we obtain the expected counts E in each county by calling the `expected()` function where we set population equal to Strata.df$population and cases equal to Strata.df$cases. There are 2 races, 2 genders and 4 age groups for each county, so number of strata is set to 2 x 2 x 4 = 16.
```{r}
( E <- expected(
  population = Strata.df$population,
  cases = Strata.df$cases, 
  n.strata = 16
) )
```

Now we add the observed count `Y`, the expected count `E` the computed SIR to `sfdf` and make a map of SIR.
```{r}
sfdf <- sfdf %>%
  mutate(Y = County.df$Y,
         E = E,
         SIR = Y/E)

ggplot(sfdf) + 
  geom_sf(aes(fill = SIR)) +
  scale_fill_gradient2(midpoint = 1, 
                       low = "blue", 
                       mid = "white", 
                       high = "red") +
  theme_minimal()
```

Counties with SIR = 1 (color white) the number of lung cancer cases observed is the same as the number of expected cases. In counties where SIR > 1 (color red), the number of lung cancer cases observed is higher than the expected cases. Counties where SIR < 1 (color blue) have fewer lung cancer cases observed than expected.

## Estimating disease risk in small areas

With rare diseases in regions with few people, the expected counts may be very low and SIRs may be misleading. Therefore, it is preferred to estimate disease risk by using models that borrow information from neighboring areas, and incorporate covariate information. This results in smoothing (shrinkage) of extreme values.

Let the observed counts $Y_i$ be modeled with a Poisson distribution having a mean $E_i\theta_i$, where $E_i$ are the expected counts and $\theta_i$ are the relative risks. The logarithm of the relative risk is expressed as the sum of an intercept that models the overall disease risk level, and random effects to account for local variability.

The relative risk quantifies whether an area has a higher ($\theta_i > 1$) or lower ($\theta_i < 1$) risk than the average risk in the population. For example if $\theta_i = 2$, then the risk in area $i$ is twice the average risk in the population.

The model is expressed as
$$
Y_i \sim \hbox{Poisson}(E_i\theta_i), i = 1, \ldots, n, \\
\log(\theta_i) = \alpha + u_i + v_i
$$

The parameter $\alpha$ represents the overall risk in the region of study, $u_i$ is the spatial random effect respresenting the dependency in risk across neighboring areas (spatial autocorrelation), and $v_i$ is uncorrelated random noise modeled as $v_i \sim N(0, \sigma_v^2)$.

It is common to include covariates to quantify risk factors (e.g., distance to nearest coal plant). Thus the log($\theta_$) is expressed as
$$
\log(\theta_i) = \alpha + \beta x_i + u_i + v_i
$$
where $x_i$ is the covariate value in area $i$ and $\beta$ is the associated coefficient. The coefficient is interpreted such that a one-unit increase in $x$ changes the relative risk by a factor $\exp(\beta)$, holding the other parameters constant.

A popular form for the combined spatial random effect and uncorrelated random effect terms is the Besag-York-Mollié (BYM) model which assigns a conditional autoregressive distribution to $u_i$ as
$$
u_i | {\bf u_{j \ne i}} \sim N(\bar u_{\delta_i}, \frac{\sigma_u^2}{n_{\delta_i}})
$$
where $\bar  u_{\delta_i} = \Sigma_{j \in \delta_i} u_j/n_{\delta_i}$ and where $\delta_i$ is the set of neighbors of area $i$ and $n_{\delta_i}$ is the number of neighbors of area $i$.

In words, the logarithm of the disease incidence rate in area $i$ conditional on the incidence rates in the neighborhood of $i$ is modeled with a normal distribution centered on the neighborhood average ($\bar  u_{\delta_i}$) with a variance scaled by the number of neighbors. This is called the conditional autoregressive (CAR) distribution.

### Syntax in INLA

The syntax for the BYM model is given as
```{r eval=FALSE}
formula <- Y ~
  f(id_area_u, model = "besag", graph = g, scale.model = TRUE) +
  f(id_area_v, model = "iid")
```

The formula includes the response in the left-hand side, and the fixed and random effects in the right-hand side. By default, the formula includes an intercept. 

Random effects are set using `f()` with parameters equal to the name of the index variable, the model, and other options. The BYM formula includes a spatially structured component with index variable with name `id_area_u` and equal to c(1, 2, ..., I), and model `"besag"` with a CAR distribution and with neighborhood structure given by the graph `g`. 

The option scale.model = TRUE is used to make the precision parameter of models with different CAR priors comparable (Freni-Sterrantino, Ventrucci, and Rue 2018). The formula also includes an unstructured component with index variable with name idareav and equal to c(1, 2, ..., I), and model "iid". This is an independent and identically distributed zero-mean normally distributed random effect. Note that both the variables idareau and idareav are vectors with the indices of the areas. These two variables are identical; however, they still need to be specified as two different objects since R-INLA does not allow to include two effects with f() that use the same index variable. The BYM model can also be specified with the model "bym" which defines both the spatially structured and unstructured components  
u
i
  and  
v
i
 .