# Latent Field Modeling using INLA

https://www.paulamoraga.com/book-geospatial/sec-geostatisticaldataexamplespatial.html

In this chapter we show how to fit a geostatistical model to predict malaria prevalence in The Gambia using the stochastic partial differential equation (SPDE) approach and the R-INLA package (@RueEtAl2014). 

We use data of malaria prevalence in children obtained at 65 villages in The Gambia which are contained in the {geoR} package (@RibeiroEtAl2020), and high-resolution environmental covariates downloaded with the {raster} package (@Hijmans2020). We show how to create a triangulated mesh that covers The Gambia, the projection matrix and the data stacks to fit the model. 

Then we show how to manipulate the results to obtain the malaria prevalence predictions, and 95% credible intervals denoting uncertainty. We also show how to compute exceedance probabilities of prevalence being greater than a given threshold value of interest for policy making. 

Results are shown by means of interactive maps created with the {tmap} package (@Tennekes2018).

### Prepare the data

First, we load the {geoR} package and attach the data `gambia` which contains information about malaria prevalence in children obtained at 65 villages in The Gambia.
```{r}
library(geoR)
data(gambia)
```

Next we inspect the data and see it is a data frame with 2035 observations and the following 8 variables:

`x`: x coordinate of the village (UTM),
`y`: y coordinate of the village (UTM),
`pos`: presence (1) or absence (0) of malaria in a blood sample taken from the child,
`age`: age of the child in days,
`netuse`: indicator variable denoting whether the child regularly sleeps under a bed net,
`treated`: indicator variable denoting whether the bed net is treated,
`green`: satellite-derived measure of the greenness of vegetation in the vicinity of the village,
`phc`: indicator variable denoting the presence or absence of a health center in the village.

```{r}
head(gambia)
```

Data in gambia are given at an individual level. Here, we do the analysis at the village level by aggregating the malaria tests by village. We create a data frame called d with columns containing, for each village, the longitude and latitude, the number of malaria tests, the number of positive tests, the prevalence, and the altitude.

#### Malaria prevalence

We can see that `gambia` has 2035 rows and the matrix of the unique coordinates has 65 rows. This indicates that 2035 malaria tests were conducted at 65 locations.
```{r}
dim(gambia)
dim(unique(gambia[, c("x", "y")]))
```

We create a data frame called `df` containing, for each village, the coordinates (`x`, `y`), the total number of tests performed (`total`), the number of positive tests (`positive`), and the malaria prevalence (`prev`). 

In data `gambia`, column `pos` indicates the tests results. Positive tests have `pos` equal to 1 and negative tests have `pos` equal to 0. Therefore, we can calculate the number of positive tests in each village by adding up the elements in `gambia$pos`. Then we calculate the prevalence in each village by calculating the proportion of positive tests (number of positive results divided by the total number of tests in each village). 

We create the data frame `df` using the {dplyr} package as follows:
```{r}
library(dplyr)

df <- gambia %>%
  group_by(x, y) %>%
  summarize(
    total = n(),
    positive = sum(pos),
    prev = positive / total
    )
head(df)
```

Next we create a simple feature data frame by making the `x` and `y` columns the spatial coordinates.
```{r}
library(sf)

sfdf <- st_as_sf(x = df, 
                 coords = c("x", "y"),
                 crs = 32628)

library(mapview)

mapView(sfdf, 
        zcol = "prev")
```

#### Environmental factors

We model malaria prevalence using a covariate that indicates the altitude in The Gambia. This covariate can be obtained with the `getData()` function of the {raster} package. This package can be used to obtain geographic data from anywhere in the world. 

In order to get the altitude values in The Gambia, we need to call `getData()` with the three following arguments:

* name of the data equal to "alt",
* country equal to the 3 letters of the International Organization for Standardization (ISO) code of The Gambia (GMB),
* mask equal to TRUE so the neighboring countries are set to NA.

```{r}
library(raster)

r <- getData(name = "alt", 
             country = "GMB", 
             mask = TRUE)
```

We make a map with the altitude raster using functions from the {tmap} package.
```{r}
library(tmap)

tmap_mode(mode = "view")

tm_shape(r) +
  tm_raster() +
tm_shape(sfdf) +
  tm_dots(col = "prev", size = .1)
```

We add the the altitude values to the data frame `df` to be able to use it as a covariate in the model. Since the raster is longitude/latitude we convert the village locations to longitude/latitude adding them to the data frame.
```{r}
sfdfT <- sfdf %>%
  st_transform(crs = 4326)

df[, c("long", "lat")] <- st_coordinates(sfdfT)
```

Now we get the altitude values at the village locations using the `extract()` function from {raster}. The first argument of this function is the altitude raster (`r`). The second argument is a two-column matrix with the coordinates where we want to know the values, that is, the coordinates of the villages given by `d[, c("long", "lat")]`. We assign the altitude vector to the column `altitude` of the data frame `df`.
```{r}
df$altitude <- raster::extract(r, df[, c("long", "lat")])

head(df)
```

### Specify the model

Here we specify the model (mathematically and heuristically) to predict the prevalence of malaria in The Gambia using the stochastic partial differential equation (SPDE) approach and functions from the {INLA} package.

Mathematically, we assume that conditional on the true prevalence $P({\bf x}_i)$ at location ${\bf x}_i$, i = 1, $\ldots, n$, the number of positive results $Y_i$ out of $N_i$ people sampled follows a binomial distribution
$$
Y_i|P({\bf x}_i) \sim \hbox{Binomial}(N_i, P({\bf x}_i)) \\
\hbox{logit}[P({\bf x}_i)] = \beta_0 + \beta_1 \hbox{altitude} + S({\bf x}_i)
$$

Here $\beta_0$ is the intercept, $\beta_1$ is the coefficient on altitude and $S({\bf x}_i))$ is a spatial random effect (spatial autocorrelation) that follows a zero-mean Gaussian process with a Mat'ern covariance function
$$
\hbox{Cov}(S({\bf x}_i), S({\bf x}_j)) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa ||{\bf x}_i - {\bf x}_j||)^\nu K_\nu (\kappa ||{\bf x}_i - {\bf x}_j||)
$$
where $K_\nu$($\cdot$) is the modified Bessel function of the second kind with order $\nu$ > 0. $\nu$ is the smoothness parameters, $\sigma^2$ is the variance, and $\kappa$ > 0 is related to the practical range $\rho = \sqrt{8\nu}/\kappa$ which is the distance at which the spatial correlation is close to .1.

#### Constructing a mesh

First we extract the locations of the malaria cases as longitude and latitude coordinates.
```{r}
LonLat <- sfdf %>%
  st_transform(crs = 4326) %>%
  st_coordinates() 
head(LonLat)
```

We need to build a triangulated mesh using the longitude and latitude coordinates that covers The Gambia over which to make the random field discretization. We do this using Delauney triangulation. We use the `inla.mesh.2d()` function passing the following parameters:

* `loc`: location coordinates that are used as initial mesh vertices,
* `max.edge`: values denoting the maximum allowed triangle edge lengths in the region and in the extension,
* `cutoff`: minimum allowed distance between points.

Here, we call `inla.mesh.2d()` setting `loc` equal to the matrix with the coordinates `coo`. We set `max.edge = c(.1, 5)` to use small triangles within the region, and larger triangles in the extension. We also set `cutoff = .01` to avoid building many small triangles where we have some very close points.
```{r}
library(INLA)

coo <- cbind(LonLat[, 1], LonLat[, 2])
mesh <- inla.mesh.2d(loc = coo, 
                     max.edge = c(.1, 5),
                     cutoff = .01)
```

The number of the mesh vertices is given by `mesh$n` and we can plot the mesh with `plot(mesh)`.
```{r}
mesh$n

plot(mesh)
points(coo, col = "red")
```

#### Defining and indexing the spatial random effects term on the mesh 

Then, we use the `inla.spde2.matern()` function to define the spatial random effect on the mesh.
```{r}
sre <- inla.spde2.matern(mesh = mesh, 
                         alpha = 2, 
                         constr = TRUE)
```
Here, we set `constr = TRUE` to impose an integrate-to-zero constraint and `alpha is a parameter related to the smoothness parameter of the process, namely, $\alpha = \nu + d/2$. 

In this example, we set the smoothness parameter $\nu$ is set to 1 and in the spatial case $d$ = 2 so $alpha$ =  1 + 2/2 = 2.

Next we need to index each of the mesh nodes (vertices). We do this with the `inla.spde.make.index()` function where we specify the name of the effect and the number of nodes in the spatial random effect term (`sre$n.spde`).
```{r}
indexs <- inla.spde.make.index(name = "s",
                               n.spde = sre$n.spde)
lengths(indexs)
```

This creates a list with vector `s` equal to `1:sre$n.spde`, and vectors `s.group` and `s.repl` that have all elements equal to 1s and length given by the number of mesh nodes.

#### Projecting the observation locations to the mesh

Next we need to build a matrix A that projects the locations of the observations to the mesh nodes. The projection matrix is built with the `inla.spde.make.A()` function as follows.
```{r}
A <- inla.spde.make.A(mesh = mesh,
                      loc = coo)
```

#### Defining a prediction grid amd projecting the grid locations to the mesh

Next we need to define where we want the predictions to be made. The raster of elevations provides a set of locations and we can extract the raster cells as points with the `rasterToPoints()` function from the {raster} package. Since there are many cells we first reduce this number by a factor of five with the `aggregate()` function taking the mean elevation over five cells in each direction.
```{r}
ra <- raster::aggregate(r,
                        fact = 5,
                        fun = mean)
dp <- rasterToPoints(ra)
dim(dp)
head(dp)
```

Next we extract just the spatial coordinates of the prediction locations and project these locations to the mesh.
```{r}
coop <- dp[, c("x", "y")]

Ap <- inla.spde.make.A(mesh = mesh,
                       loc = coop)
```

#### Organize the model inputs

We use the `inla.stack()` function to organize data, effects, and projection matrices with the following arguments:

* `tag`: string to identify the data,
* `data`: list of data vectors,
* `A`: list of projection matrices,
* `effects`: list with fixed and random effects.

We construct a stack called `stk.e` with data for estimation and we tag it with the string "est". 

The fixed effects are the intercept (b0) and a covariate (altitude). The random effect is the spatial Gaussian random field (s). Therefore, the `effects` argument gets a list with a data.frame with the fixed effects, and s containing the indices of the random effect (`indexs)`. 

The argument `A` is set to a list where the second element is `A`, the projection matrix for the random effects, and the first element is 1 to indicate the fixed effects are mapped one-to-one to the response. 

In the `data` argument we specify the response vector and the number of trials. 
```{r}
stk.e <- inla.stack(tag = "est",
                    data = list(y = df$positive, numtrials = df$total),
                    A = list(1, A),
                    effects = list(data.frame(b0 = 1, altitude = df$altitude), s = indexs)
)
```

We also construct a stack for prediction that called `stk.p`. This stack has tag equal to "pred", the response vector is set to NA, and the data is specified at the prediction locations. Finally, we put `stk.e` and `stk.p` together in a `stk.full`.


### Fit the model

Model formula

Call to inla()
